// server/routes/uploadRoutes.js

import express from 'express';
import multer from 'multer';
import path from 'path';
import fs from 'fs';
import crypto from 'crypto'; // For generating unique filenames
import { fileURLToPath } from 'url'; // To handle __dirname in ES modules

const router = express.Router();

// --- Configuration ---
const MAX_FILE_SIZE_MB = 5;
const MAX_FILE_SIZE_BYTES = MAX_FILE_SIZE_MB * 1024 * 1024;
const ALLOWED_MIME_TYPES = ['image/jpeg', 'image/png', 'image/gif', 'image/webp'];

// Determine the correct base path relative to this file
// This assumes uploadRoutes.js is inside server/routes/
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
// Go up two levels (from routes/ then from server/) to reach project root, then into public/uploads/images
const UPLOAD_DIR_RELATIVE_TO_PROJECT_ROOT = 'public/uploads/images';
const UPLOAD_DIR_ABSOLUTE = path.join(__dirname, '..', '..', UPLOAD_DIR_RELATIVE_TO_PROJECT_ROOT);

// Ensure the upload directory exists
try {
  if (!fs.existsSync(UPLOAD_DIR_ABSOLUTE)) {
    fs.mkdirSync(UPLOAD_DIR_ABSOLUTE, { recursive: true });
    console.log(`Created upload directory: ${UPLOAD_DIR_ABSOLUTE}`);
  }
} catch (err) {
  console.error(`CRITICAL ERROR: Could not create upload directory ${UPLOAD_DIR_ABSOLUTE}. Uploads will fail.`, err);
  // Optionally, throw the error to prevent the server from starting incorrectly
  // throw new Error(`Failed to create upload directory: ${err.message}`);
}

// --- Multer Storage Configuration ---
const storage = multer.diskStorage({
  destination: (req, file, cb) => {
    // Check if directory exists before saving (belt-and-suspenders)
    if (!fs.existsSync(UPLOAD_DIR_ABSOLUTE)) {
      return cb(new Error(`Upload directory ${UPLOAD_DIR_ABSOLUTE} not found!`), null);
    }
    cb(null, UPLOAD_DIR_ABSOLUTE); // Save files to the absolute path
  },
  filename: (req, file, cb) => {
    // Generate a unique filename: randomBytes + timestamp + original extension
    const uniqueSuffix = crypto.randomBytes(16).toString('hex');
    const extension = path.extname(file.originalname);
    const uniqueFilename = `${uniqueSuffix}-${Date.now()}${extension}`;
    cb(null, uniqueFilename);
  }
});

// --- Multer File Filter Configuration ---
const fileFilter = (req, file, cb) => {
  if (ALLOWED_MIME_TYPES.includes(file.mimetype)) {
    cb(null, true); // Accept file
  } else {
    // Reject file with a specific error message for the client
    cb(new Error(`Invalid file type. Only ${ALLOWED_MIME_TYPES.map(t => t.split('/')[1]).join(', ')} allowed.`), false);
  }
};

// --- Multer Upload Instance ---
const upload = multer({
  storage: storage,
  fileFilter: fileFilter,
  limits: {
    fileSize: MAX_FILE_SIZE_BYTES // Limit file size
  }
});

// --- Upload Route ---
// POST /api/upload/image
router.post('/image', (req, res) => {
  // Use upload.single middleware. 'imageFile' MUST match the name attribute in the frontend form input.
  const processUpload = upload.single('imageFile');

  processUpload(req, res, (err) => {
    // --- Handle Multer Errors ---
    if (err instanceof multer.MulterError) {
      console.error('Multer error during image upload:', err);
      let message = 'File upload error.';
      if (err.code === 'LIMIT_FILE_SIZE') {
        message = `File too large. Maximum size is ${MAX_FILE_SIZE_MB}MB.`;
      } else if (err.code === 'LIMIT_UNEXPECTED_FILE') {
        message = 'Unexpected file field received.';
      }
      // Add more specific Multer error codes if needed
      return res.status(400).json({ success: false, message: message });
    }
    // --- Handle File Filter Errors (or other specific errors) ---
    else if (err) {
      console.error('Non-Multer error during image upload:', err);
      // Use the error message generated by the fileFilter or storage engine
      return res.status(400).json({ success: false, message: err.message || 'File upload failed.' });
    }
    // --- Handle No File Case ---
    else if (!req.file) {
      console.warn('Image upload attempt with no file.');
      return res.status(400).json({ success: false, message: 'No image file selected.' });
    }

    // --- Upload Success ---
    console.log(`File uploaded successfully: ${req.file.path}`);

    // Construct the public URL
    // IMPORTANT: This part depends HEAVILY on how you configure static file serving in server/index.js
    // This assumes you serve 'public/uploads' directory at the '/uploads' route path.
    const filename = req.file.filename;
    // Path relative to the *publicly served* directory root
    const publiclyServedPath = `/uploads/images/${filename}`; // Matches the structure within 'public'

    // Dynamically determine the base URL (protocol + host)
    // Handles http/https and potential proxies (X-Forwarded-Proto, X-Forwarded-Host)
    const protocol = req.headers['x-forwarded-proto'] || req.protocol;
    const host = req.headers['x-forwarded-host'] || req.get('host'); // req.get('host') includes port if not standard
    const imageUrl = `${protocol}://${host}${publiclyServedPath}`;

    console.log(`Generated public Image URL: ${imageUrl}`);

    // Send success response with the public URL
    res.status(200).json({
      success: true,
      message: 'Image uploaded successfully.',
      imageUrl: imageUrl // The URL the frontend can use in <img> tags
    });
  });
});

export default router;
